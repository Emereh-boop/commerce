package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	auth "github.com/petrejonn/naytife/internal"
	"github.com/petrejonn/naytife/internal/db"
	model1 "github.com/petrejonn/naytife/internal/graph/model"
)

// SignInUser handles user sign-in and returns user data along with JWT token.
func (r *mutationResolver) SignInUser(ctx context.Context, input model1.SignInInput) (*model1.SignInUserPayload, error) {
	// Retrieve the user claims from the context
	claims, ok := ctx.Value("userClaims").(*auth.CustomClaims)
	if !ok {
		return nil, errors.New("Unauthorized")
	}
	// Log the extracted claims for debugging
	log.Printf("User claims: %+v", claims)

	// Check if the user exists in the database
	user, err := r.Repository.UpsertUser(ctx, db.UpsertUserParams{
		Auth0Sub: pgtype.Text{String: claims.Sub, Valid: true},
		Email:    claims.Email,
		Name: pgtype.Text{
			String: claims.Name,
			Valid:  true},
		ProfilePictureUrl: pgtype.Text{String: claims.ProfilePictureURL, Valid: true},
	})
	if err != nil {
		return nil, errors.New("user not found")
	}
	// Return the user data and a JWT token
	return &model1.SignInUserPayload{
		Successful: true,
		User: &model1.User{
			ID:                user.UserID.String(),
			Email:             user.Email,
			Name:              &user.Name.String,
			ProfilePictureURL: &user.ProfilePictureUrl.String,
		},
	}, nil
}

// CreateShop is the resolver for the createShop field.
func (r *mutationResolver) CreateShop(ctx context.Context, shop model1.CreateShopInput) (*model1.CreateShopPayload, error) {
	claims, ok := ctx.Value("userClaims").(*auth.CustomClaims)
	if !ok {
		return nil, errors.New("Unauthorized")
	}
	owner, err := r.Repository.GetUser(ctx, pgtype.Text{String: claims.Sub, Valid: true})
	if err != nil {
		return nil, errors.New("user not found")
	}
	param := db.CreateShopParams{
		Title:         shop.Title,
		DefaultDomain: shop.Domain,
		OwnerID:       owner.UserID,
		Status:        model1.ShopStatusPublished.String(),
		CurrencyCode:  "NGN",
	}
	dbShop, err := r.Repository.CreateShop(ctx, param)
	if err != nil {
		return nil, err
	}
	return &model1.CreateShopPayload{Successful: true, Shop: &model1.Shop{ID: dbShop.ShopID.String(), CurrencyCode: dbShop.CurrencyCode, Status: model1.ShopStatus(dbShop.Status), Title: dbShop.Title, DefaultDomain: dbShop.DefaultDomain}}, nil
}

// UpdateShop is the resolver for the updateShop field.
func (r *mutationResolver) UpdateShop(ctx context.Context, shop model1.UpdateShopInput) (*model1.UpdateShopPayload, error) {
	_, ok := ctx.Value("userClaims").(*auth.CustomClaims)
	if !ok {
		return nil, errors.New("Unauthorized")
	}
	// TODO: Check if user has update permission
	host, ok := ctx.Value("shopHost").(string)
	if !ok {
		return nil, errors.New("host not found")
	}
	dbShop, err := r.Repository.UpdateShop(ctx, db.UpdateShopParams{
		DefaultDomain: host,
		Title:         *shop.Title,
		FaviconUrl:    pgtype.Text{String: *shop.FaviconURL, Valid: true},
		CurrencyCode:  *shop.CurrencyCode,
		Status:        model1.ShopStatus(*shop.Status).String(),
		About:         pgtype.Text{String: *shop.About, Valid: true},
	})

	if err != nil {
		return nil, err
	}
	return &model1.UpdateShopPayload{Successful: true, Shop: &model1.Shop{ID: dbShop.ShopID.String(), CurrencyCode: dbShop.CurrencyCode, Status: model1.ShopStatus(dbShop.Status), Title: dbShop.Title, DefaultDomain: dbShop.DefaultDomain}}, nil
}

// CreateWhatsApp is the resolver for the createWhatsApp field.
func (r *mutationResolver) CreateWhatsApp(ctx context.Context, input model1.CreateWhatsAppInput) (*model1.CreateWhatsAppPayload, error) {
	panic(fmt.Errorf("not implemented: CreateWhatsApp - createWhatsApp"))
}

// UpdateWhatsApp is the resolver for the updateWhatsApp field.
func (r *mutationResolver) UpdateWhatsApp(ctx context.Context, input model1.UpdateWhatsAppInput) (*model1.UpdateWhatsAppPayload, error) {
	panic(fmt.Errorf("not implemented: UpdateWhatsApp - updateWhatsApp"))
}

// Shop is the resolver for the shop field.
func (r *queryResolver) Shop(ctx context.Context, id string) (*model1.Shop, error) {
	shopId, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	shop, err := r.Repository.GetShop(ctx, shopId)
	if err != nil {
		return nil, err
	}
	return &model1.Shop{Title: shop.Title}, nil
}

// MyShops is the resolver for the myShops field.
func (r *queryResolver) MyShops(ctx context.Context) ([]model1.Shop, error) {
	claims, ok := ctx.Value("userClaims").(*auth.CustomClaims)
	if !ok {
		return nil, errors.New("Unauthorized")
	}
	owner, err := r.Repository.GetUser(ctx, pgtype.Text{String: claims.Sub, Valid: true})
	if err != nil {
		return nil, err
	}
	shops, err := r.Repository.GetShopsByOwner(ctx, owner.UserID)
	if err != nil {
		return nil, err
	}
	shopList := make([]model1.Shop, len(shops))
	for i, shop := range shops {
		shopList[i] = model1.Shop{ID: shop.ShopID.String(), Title: shop.Title, Status: model1.ShopStatus(shop.Status), DefaultDomain: shop.DefaultDomain, CurrencyCode: shop.CurrencyCode, FaviconURL: &shop.FaviconUrl.String, About: &shop.About.String}
	}
	return shopList, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
